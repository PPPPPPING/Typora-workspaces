# 基本数据类型和包装类的区别

- 包装类是对象，拥有方法和字段，对象的调用都是通过引用对象的地址，基本类型不是。
- 包装类型是引用的传递，基本类型是值的传递。
- 声明方式不同，基本数据类型不需要new关键字，而包装类型需要new在堆内存中进行new来分配内存空间。
- 存储位置不同，基本数据类型直接将值保存在值栈中，而包装类型是把对象放在堆中，然后通过对象的引用来调用他们。
- 初始值不同，eg： int的初始值为 0 、 boolean的初始值为false 而包装类型的初始值为null。

# 冒泡排序

```java
package com.chenxi.listTestDemo.bubblesort;

/**
 * 冒泡排序
 */
public class BubbleSort {
    public static void main(String[] args) {
        int[] ints = new int[]{-10, -20, -30, -15, 10, 16, 18, 19, 60, 45, 88};
        for (int i = 0; i < ints.length - 1; i++) {
            for (int j = 0; j < ints.length - 1 - i; j++) {
                if (ints[j] > ints[j + 1]) {
                    int exchange = ints[j];
                    ints[j] = ints[j + 1];
                    ints[j + 1] = exchange;
                }

            }
        }
        for (int i = 0; i < ints.length; i++) {
            System.out.println(ints[i] + "\t");
        }
    }
}
```

# 重载与重写的区别

- 重写就是子类继承父类了，但是子类不想要父类那个方法，就可以将该方法重写
- 重载就是方法名相同，但是形参不同

# equals与==的区别

- ==比较的地址值
- equals比较的是内容

# JVM的原理

是java虚拟机，运行和管理我们平时所写的java的class文件工具，自动管理和内存回收，不同的操作平台安装不同的jvm从而实现我们代码能跨平台。如果我们的代码出现了问题，恰好在jvm层面，所以要熟悉jvm的运行机制

# Object类里面有哪些方法？

- ### getClass()

  Class<? extendsObject> getClass() 返回一个对象的运行时类。

- ### hashCode()

  int hashCode() 返回该对象的哈希码值。

- ### equals()

  boolean equals(Object obj) 指示某个其他对象是否与此对象“相等”。

- ### toString()

  String toString() 返回该对象的字符串表示。

- ### clone()

  protected Object clone() 创建并返回此对象的一个副本。

- ### wait()

  void wait() 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。void wait(long timeout) 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或notifyAll() 方法，或者超过指定的时间量。
  void wait(long timeout, int nanos) 导致当前的线程等待，直到其他线程调用此对象的 notify()。

- ### notify()

  void notify() 唤醒在此对象监视器上等待的单个线程。

- ### notifyAll()

  void notifyAll() 唤醒在此对象监视器上等待的所有线程。

- ### finalize()

  protected void finalize() 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。

# Springbooot+Vue项目流程

首先建立一个前端Vue的项目。
然后建立一个maven项目，将网页的src和xml导入。
然后建立一个common包放配置类。
前端字段对应好之后。
utils > request.js 复制axios的代码。

```vue
request.post("/onepice",this.form).then(res => {
  console.log(res)
})

前面要加上端口：
request.post("localhost9090/onepice",this.form).then(res => {
  console.log(res)
})

跨域配置

创建vue.config.js
```

# String、StringBuffer和StringBuilder的异同？

相同点：底层都是通过char数组实现的
不同点：

- String对象一旦创建，其值是不能修改的，如果要修改，会重新开辟内存空间来存储修改之后的对象；而StringBuffer和StringBuilder对象的值是可以被修改的；
- StringBuffer几乎所有的方法都使用synchronized实现了同步，线程比较安全，在多线程系统中可以保证数据同步，但是效率比较低；而StringBuilder 没有实现同步，线程不安全，在多线程系统中不能使用 StringBuilder，但是效率比较高。
- 如果我们在实际开发过程中需要对字符串进行频繁的修改，不要使用String，否则会造成内存空间的浪费；当需要考虑线程安全的场景下使用 StringBuffer，如果不需要考虑线程安全，追求效率的场景下可以使用 StringBuilder。