# 集合

## Collection的子接口之一List

```java
reverse(List):反转List中的顺序
shuffle(List)：对List集合元素进行随机排序
sort(List):根据元素的自然排序对指定List集合元素按照升序排序
sort(List,Conparator):根据指定的Comparator产生的顺序对List集合进行排序
swap(List,int,int):将指定list集合中的i处元素和j处元素进行调换
    
Object max(Collection):根据元素的自然顺序，返回给定集合中最大的元素
Object max(Collection,Comparator):根据Comparator指定的顺序，返回给定集合中的最大
Object min(Collecion)
Object min(Collection,Comparator)
int frequency(Collecion,Object):返回指定集合中指定元素出现的次数
void copy(List dest,List src):将src中的内容复制到dest中
boolean replaceAll(List list,Object oldVal,Object newVal):使用新值替换list对    
```

List是有序的，是可重复的，动态数组，一旦初始化了，长度就不能改变。

### ArrayList、LinkList和Vector三者的区别

都是List接口的实现类，存储数据的特点相同，都是有序，可重复。底层使用object[]存储。

- ArrayList：作为list接口的主要实现类，是线程不安全的，效率高。
- LinkList：对频繁的插入，删除操作，使用此类的效率必ArrayList高，底层使用的是双向链表。
- Vector：古老实现类，线程安全的，效率低。底层使用object[]存储。

### ArrayList和LinkedList的区别

可以从四个角度看待问题：数据结构、内存分配、默认长度、扩容机制。

- 使用场景ArrayList是动态数组，LinkList是双向列表。
- 数组：内存中开辟空间就相当一群人 站成一对，从0开始。
- 数组可分为索引数组和关联数组。
- ArrayList是索引数组中的动态数组。

####  Arrayist

1. 基于索引的动态数组，开辟的内存空间是连续的，这也为他查询效率奠定了基础。
2. 初始化时默认容量是10，而后按照当前的容量的1.5被进行扩容。
3. 适用在查找多，增删少的场景。

#### LinkedList

1. 双向链表，开辟的内存空间是可连续的，也可不连续，节点与节点之间通过指针关联，当增删时不需要关心位置，这也为它增删效率奠定了基础。
2. 由于时双向列表，所以无初始容量，无扩容机制。
3. 适用在增删多，查找少的场景。

## Collection的子接口之一Set

set接口是无序的，不可重复的。

1. Set接口的框架

collection接口；单列集合，用来存储一个一个的对象。

Set接口；存储无序的，不可重复的数据。

HashSet：作为Set接口的主要实现类，线程是不安全的，可以存储null值。

LinkedHashSet：作为HashSet的子类，遍历其内部数据时i，可以按照添加的。

TreeSet：可以按照添加对象的指定属性，进行排序。

2. Set接口中没有额外定义新的方法，使用的都是collection中声明的方法。

## map

Map：双列数据，存储key-value对的数据。

HashMap：作为Map的主要实现类，线程是不安全的，效率高，存储null的key和value。

LinkedHashMap：保证在遍历map元素时，可以按照提那家店顺序实现遍历；原因：在原有的HashMap底层的结构基础上，添加了一对指针，指向前一个和后一个元素，对于频繁的遍历操作，子类执行效率高于HashMap。

TreeMap保证按照添加到key-value对进行排序，实现排序遍历，此时考虑key的自然排序或定制排序；底层时红黑树。

hashTable：作为古老的实现类。线程时安全的，但是效率很低，不能存储null的key和value。

properties：常用来处理配置文件，key和value都是String类型。

### HashMap的底层

数组+链表（jdk7以及以前）

数组+链表+红黑树（jdk8）

### HashMap和HashSet的区别

HashSet的实现方式大致如下，通过一个HashMap存储元素，元素是存放在HashMap的Key中，而Value统一使用一个Object对象。

### HashMap和TreeMap的区别

Map：在数组中是通过数组下标来对 其内容进行索引的，而Map是通过对象来对 对象进行索引的，用来 索引的对象叫键key，其对应的对象叫值value。

- HashMap是通过hashcode()对其内容进行快速查找的；HashMap中的元素是没有顺序的；TreeMap中所有的元素都是有某一固定顺序的，如果需要得到一个有序的结果，就应该使用TreeMap。
  HashMap和TreeMap都不是线程安全的。
- HashMap继承AbstractMap类；覆盖了hashcode() 和equals() 方法，以确保两个相等的映射返回相同的哈希值；TreeMap继承SortedMap类；他保持键的有序顺序；
- HashMap：基于hash表实现的；使用HashMap要求添加的键类明确定义了hashcode() 和equals() （可以重写该方法）；为了优化HashMap的空间使用，可以调优初始容量和负载因子；
- TreeMap：基于红黑树实现的；TreeMap就没有调优选项，因为红黑树总是处于平衡的
- HashMap：适用于Map插入，删除，定位元素。
- TreeMap：适用于按自然顺序或自定义顺序遍历键（key）。